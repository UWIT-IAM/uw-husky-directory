# Conventions & Style Guide


## Field Names

**Keep field names DRY and self-documenting.** (Yes, these may sometimes be at odds.)

```
class OrangeThings(BaseModel):
    orange_ball: str
    orange_bowl: str
    orange_cup: str
```

The above field names _are_ self-documenting, but they are also repetitive. If they
are in a class called "OrangeThings" it's redundant to prefix every one of them 
with `orange_`; one should be able to assume that `OrangeThings.ball` would indicate
an orange ball.


```
class OrangeThings(BaseModel):
    ball: str
    bowl: str
    cup: str
```

However, depending on the use case for the model, it may be contextually clearer due to 
abstraction or data munging to explicitly prefix the fields. 

In short: keep it brief unless you have a use case where that brevity adds
unnecessary confusion.

## Default Values


### Null Values

If it is expected that a field's value can be `None`, mark the field as `Optional`. By 
default, it will be set to `None`; you may override this to populate some default value
if needed.

Always default to None:
 > `foo: Optional[str]`

Default to `"my default"`, but allow `None`:
 > `foo: Optional[str] = Field("my default")`


**Prefer required fields.** Think about the fields you are declaring. It might be 
_possible_ for a field to be null, but is it _expected_ in our use case? We don't want 
to simply abstract upstream APIs; we want to make sure our models tell the story of 
how we expect them to be used.

Unless a field really can and should be `None` to serve some purpose, we should 
require a value. (That doesn't mean a null value should be considered a bad idea,
just that we should be intentional about how we express our intent.)

### Dictionaries and Lists

When your data type is a dictionary or list, prefer to set a default of an empty
item instead of a value of None, so that dependents can at least assume an iterable:

Here is an example of what we *DO NOT* want:

```
class Foo:
    bars: Optional[List[str]]


def get_bars(foo: Foo):
   if not foo.bars:  # Empty list OR None, convert to empty list:
       return []
   return [ build_bar_from_template(b) for b in foo.bars ]
```

This requires dependents to do null-checks before iteration, which is ugly and
annoying, because this has to be done every time the field is accessed. Instead,
express your intent eagerly:

```
class Foo:
    bars: List[str] = []

def get_bars(foo: Foo):
    return [ build_bar_from_Template(b) for b in foo.bars ]
```

Because `bars` is now required, but with an acceptable default, callers no longer have 
to guess at whether or not they have an iterable.


## To `Field` or not to `Field`

In short, unless you need extra annotations on your field, don't use the Field class
explicitly. 

Use `Field` if:

- You must declare an alias that falls out of line with the default alias generator.
- You want to add helpful documentation using the `description` attribute.
- You need to declare special, extra parameters on the field (for advanced pydantic-fu).
- You find some other use case that requires you to use `Field`.

Otherwise, just use the shorthand. The following two statements are functionally
 equivalent:

```
foo: str = Field('my default')
foo: str = 'my default'
```

### The ellipsis: `...`

This is legal python syntax that Pydantic has adopted to mean "No default" when using
`Field` annotations on required fields. 

Here, we have a field, `foo` that is required (not marked as `Optional`), but has an 
unconventionally cased alias that requires us to declare it explicitly. We use the 
ellipsis to signal, "ignore the first parameter." 
This is a canonical pydantic expression to distinguish between a default value of
 `None` and "No default is set."

 > `foo: str = Field(..., alias="FoO")`


## Aliases

By default, fields are named as they are declared:

> `foo_bar: str`

This creates a field named `foo_bar`. Sometimes, when parsing from or exporting for 
other services, you need to import/export a field under a different name. (Example: 
using snake_case in python backends, but converting to camelCase for frontend
 javascript.)
 
To do this, you can declare an alias:

> `foo_bar: str = Field(..., alias='fooBar')`

Aliases [can easily be autogenerated](
https://pydantic-docs.helpmanual.io/usage/model_config/#alias-generator) 
by declaring an `alias_generator` in a pydantic model config. See Pydantic
documentation for more information.

If you are using an alias generator, you only need to declare aliases that go against 
the generator.

For instance, if we have a generator that prefixes fields with `data_`, (turning
`foo_bar` into `data_foo_bar`), but know we have one field that is expected to instead
be prefixed with `meta_`, we can do something like this:
 
```python
from pydantic import BaseModel, Field
class MyModel(BaseModel):
    class Config:
        alias_generator = lambda x: f'data_{x}'
    foo_bar: str   # Uses the generator
    bar_baz: str
    special_value: str = Field(..., alias='meta_special_value')

instance = MyModel(foo_bar='hi', bar_baz='bye', special_value='shh')
instance.dict(by_alias=True)
```

would output: 

> `{data_foo_bar: "hi", data_bar_baz: "bye", meta_special_value: "shh"}`

So, **TL;DR**: Only use aliases for exceptions to some declared alias rule for your
model.
