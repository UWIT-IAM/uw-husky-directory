name: Deploy the UW Directory

on:
  workflow_dispatch:
    inputs:
      cluster:
        description: cluster. Choose from dev/eval/prod.
        default: eval
        required: true
      rfc:
        description: >
          rfc. The RFC number or link associated with this
          deployment. Required when deploying to prod.
      version:
        description: >
          version. The version to deploy (e.g., '1.2.3'). If not provided,
          the most recent release candidate will be used (eval will source from dev,
          prod will source from eval).

env:
  SLACK_BOT_TOKEN: ${{ secrets.ACTIONS_SLACK_BOT_TOKEN }}
  DRY_RUN: false
  STEP_SCRIPTS: ${{ github.workspace }}/.github/steps/deploy
  target_cluster: dev

jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 1
    permissions:
      contents: read
      id-token: write
    env:
      input_version: ${{ github.event.inputs.version }}
      input_rfc: ${{ github.event.inputs.rfc }}
      input_cluster: ${{ github.event.inputs.cluster }}
    steps:
      - uses: actions/checkout@v3
      - uses: abatilo/actions-poetry@v2.1.6
      - run: |
          sudo apt-get -y install jq
#          poetry install
          poetry run pip install uw-it-build-fingerprinter tox
      - uses: UWIT-IAM/actions/configure-gcloud-docker@0.1
        with:
          gcloud-token: ${{ secrets.GCR_TOKEN }}

      # When performing an automated dry run from a push, we will be running using
      # the basic default command of: ./deploy-sh --dry-run --target-cluster dev
      - if: github.ref != 'refs/heads/main'
        run: |
          echo "DRY_RUN=true" >> $GITHUB_ENV
          echo "deployment_qualifier=[DRY_RUN]" >> $GITHUB_ENV
        name: Configure dry run deployment

      - name: Update env with promotion version
        run: |
          source ./scripts/globals.sh
          target_version=$(get_promotion_version ${{ inputs.cluster }})
          echo "target_version=${target_version}" >> $GITHUB_ENV
        if: env.target_version == ''

      - name: Configure slack notification canvas
        id: configure-canvas
        run: ${STEP_SCRIPTS}/configure-canvas.sh

      - uses: uwit-iam/actions/set-up-slack-notification-canvas@0.1
        with:
          json: ${{ steps.configure-canvas.outputs.slack-canvas }}
        id: slack
        name: Create slack notification canvas

      - uses: uwit-iam/actions/update-slack-workflow-canvas@0.1
        with:
          command: add-artifact
          description: ${{ steps.configure-canvas.outputs.context-artifact }}
        name: Add context artifact to slack

      - run: |
          ./scripts/deploy.sh \
            -g \
            -v ${{ env.target_version }} \
            -t ${{ env.target_cluster }} \
            -r "${{ github.event.inputs.rfc }}" \
            ${{ env.DRY_RUN == 'true' && '-x' || '' }}
        id: deploy
        name: Deploy version ${{ env.target_version }}

      - uses: uwit-iam/actions/update-slack-workflow-canvas@0.1
        with:
          command: update-workflow
          step-id: deploy
          step-status: succeeded

      - if: always() && steps.slack.outputs.canvas-id
        uses: uwit-iam/actions/finalize-slack-notification-canvas@0.1
        with:
          workflow-status: ${{ job.status == 'success' && 'succeeded' || 'failed' }}

      - run: |
          if [[ -f "webdriver-report/index.html" ]]
          then
            echo "::set-output name=upload-report::true"
          fi
        id: report

      - if: always() && steps.report.outputs.upload-report == 'true'
        uses: actions/upload-artifact@v3
        with:
          name: web test storyboards for for ${{ github.sha }}
          path: ./webdriver-report
