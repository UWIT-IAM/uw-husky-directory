# This workflow is responsible for:
# - Creating a docker image from this commit
# - Pushing the docker image to a public repository
# - Running any validation tests within the built image so we can validate it exactly as it will run when deployed
#
name: Commit Image Workflow
# This runs on every push, so that every push gets its own image and validation tests. This also means
# we can use any push as a rollback point for any live instance, if something goes wrong, and be able to find
# the image is easily using the commit hash as a reference.
on:
  - pull_request
  - push
# Sets up some aliases so we can keep these values DRY
env:
  APP_NAME: husky-directory
  DOCKERHUB_ORG: uwitiam
jobs:
  # This job simply builds and outputs some variables used in other contexts
  configure-image:
    runs-on: ubuntu-latest
    steps:
      - # Creates a tag like "commit-abcde12345" where abcde12345 is a substring of the first 10 commit SHA characters.
        name: Create commit tag
        id: commit_tag
        run: echo ::set-output name=tag_name::commit-$(echo $GITHUB_SHA | cut -c 1-10)
      - # Creates a full image name from the above tag and environment variables
        # It will be something like: uwitiam/husky-directory:commit-abcde12345
        name: Create full image name
        id: image_name
        run: echo ::set-output name=image_name::$DOCKERHUB_ORG/$APP_NAME
      -
        name: Creates a fully qualified image name with the tag
        id: image_with_tag
        env:
          COMMIT_TAG_NAME: ${{ steps.commit_tag.outputs.tag_name }}
          IMAGE_NAME: ${{ steps.image_name.outputs.image_name }}
        run: echo ::set-output name=name_with_commit_tag::${IMAGE_NAME}:${COMMIT_TAG_NAME}
    outputs:
      full_image_name: ${{ steps.image_name.outputs.image_name }}
      tag_name: ${{ steps.commit_tag.outputs.tag_name }}
      image_name_with_commit_tag: ${{ steps.image_with_tag.outputs.name_with_commit_tag }}
  # This job is responsible for building an image and uploading it to our repository. This image can later be
  # tested, deployed, and/or have other tags applied.
  build-and-push-image:
    if: ${{ github.event_name == 'push' }}
    needs: [configure-image]
    runs-on: ubuntu-latest
    env:
      # TODO:
      # In eval, we will instead use the release candidate tag name (e.g., 1.2.3-rc.1)
      # In prod, we will use the semver tag name (e.g., 1.2.3)
      BUILD_ID: ${{ github.sha }}
    steps:
      - uses: actions/checkout@master
      - # Pushes the public image based on the commit to dockerhub.
        # This could then be used in subsequent jobs to tag versions in deployment repositories.
        id: container_push
        name: Build and push docker container
        uses: elgohr/Publish-Docker-Github-Action@master
        with:
          # See docs/docker.md#github-actions-access-to-dockerhub
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}
          name: ${{ needs.configure-image.outputs.full_image_name }}
          tags: ${{ needs.configure-image.outputs.tag_name }}
          dockerfile: docker/development-server.dockerfile
          buildargs: BUILD_ID
          cache: true
  append-to-pr:
    needs: [configure-image]
    runs-on: ubuntu-latest
    env:
      IMAGE_NAME: ${{ needs.configure-image.outputs.full_image_name }}
      COMMIT_TAG: ${{ needs.configure-image.outputs.tag_name }}

    if: ${{ github.event_name == 'pull_request' }}
    steps:
      - uses: thollander/actions-comment-pull-request@master
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          message: |
            Run this build from your local repository with:

            ```bash
            ./scripts/run-development-server.sh \
              -i ${{ env.IMAGE_NAME }}:${{ env.COMMIT_TAG }} \
              -c $UWCA_CERT_PATH
            ```

            See [docs/running-the-app.md] for more information.

            [docs/running-the-app.md]: https://github.com/UWIT-IAM/uw-husky-directory/blob/main/docs/running-the-app.md

  # This uses the image built above to run validations and tests from inside the image.
  validate-image-quality:
    if: ${{ github.event_name == 'push' }}
    needs: [configure-image, build-and-push-image]
    runs-on: ubuntu-latest
    container:
      image: ${{ needs.configure-image.outputs.image_name_with_commit_tag }}
    steps:
      - uses: actions/checkout@master
      -
        name: Run validation checks and tests
        run: /scripts/validate-development-image.sh

  # If the validation steps above succeed, these deployment workflows may run.
  promote-deployment:
    # - configure-image exports variables used here
    # - validate-image-quality is required to succeed before any promotions are run
    needs: [configure-image, validate-image-quality]
    if: ${{ github.event_name == 'push' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@master
      - name: Deploy to uw-directory.iamdev.s.uw.edu from the 'main' branch
        id: deploy_main_to_dev
        env:
          IMAGE_NAME: ${{ needs.configure-image.outputs.full_image_name }}
          IMAGE_SOURCE: ${{ needs.configure-image.outputs.image_name_with_commit_tag }}
          COMMIT_TAG: ${{ needs.configure-image.outputs.tag_name }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_PASSWORD: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}
        if: github.ref == 'refs/heads/main'
        run: ./.github/scripts/promote.sh -s "${IMAGE_SOURCE}" -d "${IMAGE_NAME}:deploy-dev.${COMMIT_TAG}"
