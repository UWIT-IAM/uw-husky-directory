# This workflow is responsible for:
# - Creating a docker image from this commit
# - Pushing the docker image to a public repository
# - Running any validation tests within the built image so we can validate it exactly as it will run when deployed
#
name: Commit Image Workflow
# This runs on every push, so that every push gets its own image and validation tests. This also means
# we can use any push as a rollback point for any live instance, if something goes wrong, and be able to find
# the image is easily using the commit hash as a reference.
on: push
# Sets up some aliases so we can keep these values DRY
env:
  APP_NAME: husky-directory
  DOCKERHUB_ORG: uwitiam
jobs:
  # This job simply builds and outputs some variables used in other contexts
  configure-image:
    runs-on: ubuntu-latest
    steps:
      - # Creates a tag like "commit-abcde12345" where abcde12345 is a substring of the first 10 commit SHA characters.
        name: Create commit tag
        id: commit_tag
        run: echo ::set-output name=tag_name::commit-$(echo $GITHUB_SHA | cut -c 1-10)
      - # Creates a full image name from the above tag and environment variables
        # It will be something like: uwitiam/husky-directory:commit-abcde12345
        name: Create full image name
        id: image_name
        run: echo ::set-output name=image_name::$DOCKERHUB_ORG/$APP_NAME
      -
        name: Creates a fully qualified image name with the tag
        id: image_with_tag
        env:
          TAG_NAME: ${{ steps.commit_tag.outputs.tag_name }}
          IMAGE_NAME: ${{ steps.image_name.outputs.image_name }}
        run: echo ::set-output name=name_with_tag::${IMAGE_NAME}:${TAG_NAME}
    outputs:
      full_image_name: ${{ steps.image_name.outputs.image_name }}
      tag_name: ${{ steps.commit_tag.outputs.tag_name }}
      image_name_with_tag: ${{ steps.image_with_tag.outputs.name_with_tag }}
  # This job is responsible for building an image and uploading it to our repository. This image can later be
  # tested, deployed, and/or have other tags applied.
  build-and-push-image:
    needs: [configure-image]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@master
      # Pushes the public image based on the commit to dockerhub.
      # This could then be used in subsequent jobs to tag versions in deployment repositories.
      - id: container_push
        name: Build and push docker container
        uses: elgohr/Publish-Docker-Github-Action@master
        with:
          # See docs/docker.md#github-actions-access-to-dockerhub
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}
          name: ${{ needs.configure-image.outputs.full_image_name }}
          tags: ${{ needs.configure-image.outputs.tag_name }}
          dockerfile: docker/development-server.dockerfile
          cache: false

  # This uses the image built above to run validations and tests from inside the image.
  validate-image-quality:
    needs: [configure-image, build-and-push-image]
    runs-on: ubuntu-latest
    container:
      image: ${{ needs.configure-image.outputs.image_name_with_tag }}
    steps:
      - uses: actions/checkout@master
      -
        name: Run validation checks and tests
        run: /scripts/validate-development-image.sh
